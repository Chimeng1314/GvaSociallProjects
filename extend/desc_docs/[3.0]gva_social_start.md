# 【Swagger】

## 【1】文档官网

- https://github.com/swaggo/swag/blob/master/README_zh-CN.md

## 【2】安装步骤

- 可以翻墙

```shell
go install github.com/swaggo/swag/cmd/swag@version
```

- 无法翻墙 由于国内没法安装 [go.org/x](http://go.org/x) 包下面的东西，推荐使用 [goproxy.cn](https://goproxy.cn/zh/)
  或者 [goproxy.cn/](https://goproxy.cn/)

```shell
# Go 版本 是 1.16 ~ 最新版 可以忽略以下步骤一
# 步骤一、启用 Go Modules 功能
go env -w GO111MODULE=on 
# 步骤二、配置 GOPROXY 环境变量
go env -w GOPROXY=https://goproxy.cn,direct

# 使用如下命令下载swag
go install github.com/swaggo/swag/cmd/swag@version
```

## 【3】生成API文档[#](https://www.gin-vue-admin.com/guide/start-quickly/swagger.html#_2-生成api文档)

```shell
cd server
swag init
```

- 执行上面的命令后，server目录下会出现docs文件夹，打开浏览器复制如下地址，即可查看swagger文档

```ini
http://localhost:8888/swagger/index.html
```

## 【4】错误处理

```sh
## 如果不行，获取更新包：
go get github.com/swaggo/echo-swagger

##以上还是不行，在更新
go get github.com/alecthomas/template
```

# 【一】GVA开发流程

- gva已经提供一个基础的系统架构和开发很多后台项目管理的一些基础功能。
- 我们只需要把我们的业务和相关模块进行二次开发即可。
- 就可以形成一个完整的关于你自己的后台管理系统。

# 【二】GVA整体的项目架构分析

## 【1】前后端开发本质

- 服务端(写接口)
    - 写路由—访问某个模块的数据看表
    - 使用 `gorm` 映射 `go` 对应的结构体中
    - 将查询到的数据返回

- 客户端(调接口)
    - 根据服务端提供接口路由发起请求
    - `ginserver` 接收请求获取参数
    - 执行路由方法并返回路由定义模块的数据

## 【2】Gva项目架构分析

- gva它是一个项目搭建好的项目架构

    - 写接口

- gin

    - web服务 端口 8888
    - 如何定义路由
        - user/list,user/get.user/save,user/update,user/delete
        - course/list,course/get.course/save,course/update,course/delete —中间件
        - ...
    - 路由如何配置中间件（统一拦截）
    - 命名空间（路由组）
        - PrivateRouterGroup —中间件
            - userRouterGroup
                - user/list,user/get.user/save,user/update,user/delete
            - courseRouterGroup
                - course/list,course/get.course/save,course/update,course/delete
    - 参数的获取–request————–Req
        - 单参数 /user/get?id=1&name=zhangsan
        - 对象参数 body {id:1,name:”zhangsan”}——-
        - 路径参数 /user/get/1/zhangsan
    - 返回—response—————-VO
        - 统一返回

- gorm

    - 数据的持久层框架 对数据库表进行curd和分页等相关的操作
    - 比如对某个表的CURD的操作要非常的熟悉。

- api

    - 暴露接口

- docs

    - swagger暴露接口的目录，这个需要执行命令生成doc.go的文件

- global

    - 这个主要是用来做全局参数的一些获取，比如：配置文件解析的参数，全部可以使用

  ```sh
  package global
      
  import (
      "sync"
      
      "github.com/flipped-aurora/gin-vue-admin/server/utils/timer"
      "github.com/songzhibin97/gkit/cache/local_cache"
      
      "golang.org/x/sync/singleflight"
      
      "go.uber.org/zap"
      
      "github.com/flipped-aurora/gin-vue-admin/server/config"
      
      "github.com/go-redis/redis/v8"
      "github.com/spf13/viper"
      "gorm.io/gorm"
  )
      
  var (
      GVA_DB     *gorm.DB
      GVA_DBList map[string]*gorm.DB
      GVA_REDIS  *redis.Client
      GVA_CONFIG config.Server
      GVA_VP     *viper.Viper
      // GVA_LOG    *oplogging.Logger
      GVA_LOG                 *zap.Logger
      GVA_Timer               timer.Timer = timer.NewTimerTask()
      GVA_Concurrency_Control             = &singleflight.Group{}
      
      BlackCache local_cache.Cache
      lock       sync.RWMutex
  )
      
  // GetGlobalDBByDBName 通过名称获取db list中的db
  func GetGlobalDBByDBName(dbname string) *gorm.DB {
      lock.RLock()
      defer lock.RUnlock()
      return GVA_DBList[dbname]
  }
      
  // MustGetGlobalDBByDBName 通过名称获取db 如果不存在则panic
  func MustGetGlobalDBByDBName(dbname string) *gorm.DB {
      lock.RLock()
      defer lock.RUnlock()
      db, ok := GVA_DBList[dbname]
      if !ok || db == nil {
          panic("db no init")
      }
      return db
  }
      
  ```

  不管任何框架，未来初始化肯定只有一个地方：main函数，或者用模块的就是init方法，然后导入main方法所在的包中来进行初始化。

- initialize

    - 数据库
    - 日志
    - 缓存
    - 等等

  这里定义的所以的中间件的初始化都在这里。但是它的初始化必须是：main函数来驱动的。

- middleware——————-gin的路由

    - 中间件，包含路由资源，然后做统一处理
    - 鉴权拦截 jwt
    - casbin的权限拦截

- model

    - 和数据库表进行映射

- router

    - 提供对外的接口

- service

    - 提供CURD操作给api进行调用

- source

    - 数据初始化

- utils

    - 你要没事多看看和收集起来，

- resoruce

    - 代码自动构建的模块
